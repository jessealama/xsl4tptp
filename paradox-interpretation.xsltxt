stylesheet "1.0";
output method="text";

//////////////////////////////////////////////////////////////////////
// Stylesheet parameters
//////////////////////////////////////////////////////////////////////

// If '1', any function symbol whose name starts with skolem-prefix
// will be ignored.  (See the skolem-prefix stylesheet parameter.)
#ignore-skolems = { "1"; }

// Any function starting with this prefix will be considered a skolem
// function.
#skolem-prefix = { "sK"; }

// If we are not ignoring skolems, and this is '1', we will print them
// last.  If we are not ignoring skolems and this is not '1', then
// skolems will be presented in whatever order they appear in in the
// given interpretation.  (If we are ignoring skolems, the value of
// this variable is immaterial.)
#skolems-last = { "1"; }

//////////////////////////////////////////////////////////////////////
// Templates
//////////////////////////////////////////////////////////////////////

tpl [/] {
  if [tstp] {
    apply [tstp];
  } else {
    msg terminate="yes" "Error: the required tstp document element is missing.";
  }
}

tpl [tstp[not(formula[@name = "domain"])]] {
  msg terminate="yes" "Error: the required domain formula is missing.";
}

tpl [tstp[formula[@name = "domain"]]] {
  apply [formula[@name = "domain"]];
  if [formula[@status = "fi_predicates"]] {

  }
  if [formula[@status = "fi_functors"]] {
    choose {
      when [$ignore-skolems = "1"] {
        apply [formula[@status = "fi_functors"
                       and not(starts-with (@name, $skolem-prefix))]];
      }
      when [$skolems-last = "1"] {
        apply [formula[@status = "fi_functors"
                       and not(starts-with (@name, $skolem-prefix))]];
        apply [formula[@status = "fi_functors"
                       and starts-with (@name, $skolem-prefix)]];
      }
      otherwise {
        apply [formula[@status = "fi_functors"]];
      }
    }
  }
}

tpl print-domain {
  for-each [quantifier[@type = "universal"]] {
    for-each [*[position() = last()]] {
      choose {
        when [self::disjunction] {
          for-each [predicate[@name = "="]] {
            apply [.] mode="emit-rhs";
            if [position() < last()] {
              ", ";
            }
          }
          "\n";
        }
        when [self::predicate] {
          apply [.] mode="emit-rhs";
          "\n";
        }
        otherwise {
          msg terminate="yes" "Error: unable to handle a domain formula whose matrix is neither an atom nor a disjunction.";
        }
      }
    }
  }
}

tpl [formula[@name = "domain" and quantifier[@type = "universal"]]] {
  "Domain: ";
  print-domain ();
}

tpl [formula[@name = "domain" and not(quantifier[@type = "universal"])]] {
  msg terminate="yes" "Error: the domain formula does not have the expected shape (universal quantification).";
}

tpl [formula[@status = "fi_predicates" or @status = "fi_functors"]] {
  `@name`; "\n";
  for-each [*[1]] {
    apply [.] mode="print";
  }
  "\n";
}

tpl [*] mode="emit-rhs" {
  if [count (*) = 2] {
    apply [*[2]] mode="print";
  } else {
    msg terminate="yes" "Error: we cannot print the right-hand side of an element that does not have exactly two children.";
  }
}

tpl [*] mode="print" {
  $n = `name (.)`;
  $message = `concat ("Error: we managed to land in the default print template for a(n) ", $n, " element; something has gone awry.")`;
  msg terminate="yes" $message;
}

tpl [string[@name]] mode="print" {
  `@name`;
}
